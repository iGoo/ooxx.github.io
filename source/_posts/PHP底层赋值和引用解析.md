---
title: PHP底层赋值和引用解析
date: 2016-05-22 15:48:42
tags: [引用, zval]
categories: PHP

---



 先看一段小代码

```php
$a = 3;
$b = $a;
$b = 5;
echo $a . PHP_EOL . $b; // 3 5
```

```php
$a = 3;
$b = &$a;
$b = 5;
echo $a . PHP_EOL . $b; // 5 5
```

<!-- more -->

很明显可以看出，第一段小代码上赋值，第二段是*引用赋值* 下面来解析一下上面2步操作在zend engine中发生了什么。

对于第一段和第二段代码来说首先`$a = 3`这个操作在ZE里都是一样，产生了一个`struct`的变量结构体。类似下面这样

![变量声明.png](https://ooo.0o0.ooo/2016/05/22/5741683de4da4.png)

第二部的时候开始出现了变化, `$b = $a`和`$b = &$a`

`$b = $a`

![2.png](https://ooo.0o0.ooo/2016/05/22/574168f195c5d.png)

注意这里红框标识的，因为$b只是$a的一个副本，所以ze直接把$a的结构体`refcount_gc`这个值+1。而对于$b = &$a我们来看看发生了什么。

![4.png](https://ooo.0o0.ooo/2016/05/22/57416b95290ab.png)



第三行分析 (`$b = 5`)

> 当结构体中有2个变量指向的时候，任何一方修改都会导致结构体分裂 (copy on write)

对于第一个示例来说$b = 5意味着ZE中的结构体开始分裂，产生了另外一个结构体也就是$b = 5的这个新的结构体。而此时原来$a = 3这个结构体重的`refcount_gc` -1操作 如下图

![3.png](https://ooo.0o0.ooo/2016/05/22/57416add95506.png)

那么对于第二个示例来说，$b = 5的时候结构体不分裂，而是直接修改对应地址的值，即修改$a的值,从3修改成5。

学习整理:[PHP内存中变量赋值和引用](http://www.maiziedu.com/course/php/760-10998/)